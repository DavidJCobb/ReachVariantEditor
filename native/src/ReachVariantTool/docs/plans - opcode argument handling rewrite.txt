
/*

   Currently, every opcode argument type requires two things: an OpcodeArgValue subclass and an 
   OpcodeArgTypeinfo instance. The value subclass is used to load opcode arguments, retain their 
   values in memory, convert them to string representations, and later reserialize them as 
   binary into a game variant being saved. The typeinfo instance is going to be needed for a 
   compiler.

   So when we load, say, a Vector3 argument, we read the raw bits, store x-, y-, and z-coords, 
   and discard the bits. From this stored data, we can generate string representations, and when 
   it comes time to save the game variant we reconstruct the bits.

   However, we could probably simplify things greatly.

   Consider the following: a single OpcodeArgValue class which holds the raw bits of the opcode 
   argument, the bitcount, and a reference to an OpcodeArgTypeinfo instance; that instance would 
   contain the code to load, stringify, and compile the argument's binary data, provided to its 
   constructor as lambdas. There would be one OpcodeArgTypeinfo instance for every type, but no 
   subclasses of OpcodeArgValue.

   After all, we only need to decode the bits for four reasons:

    - Correctness checks during load.

    - Serializing to plain English.

    - Serializing to script code.

    - Inspecting and tampering with data during debugging.

   None of these reasons require that we keep the argument data in a nice, orderly representation. 
   A Vector3 doesn't need to be held in memory as x-, y-, and z-coords; it can be held as raw 
   bits, with the typeinfo used to stringify it as needed. (On the rare occasions where it's not 
   sufficient to stringify the value, I can just view the bits in my debugger, read through the 
   code to interpret them, and manually reconstruct the value with pen and paper -- slow, but an 
   acceptable price to pay for much smaller and simpler code.)
   
   ---
   
   Some notes:
   
    - OpcodeArgValue in this design can store up to 64 bits. 32 bits is not enough; variables with 
      scope, which, and index values can use 16-bit integers as the which and/or index.
   
    - We should implement this before proceeding much further with the decompiler code, since 
      we'll basically get the decompiler for free: we'll have to make it when creating the typeinfo 
      instances. We can do this without breaking the existing code by defining these new classes as 
      OpcodeArgRawValue and OpcodeArgRawTypeinfo; once all types are defined, we can switch the 
      code to use these "raw" classes; and once that code is confirmed to work properly, we can 
      delete the old classes and find-and-replace "OpcodeArgRaw" with "OpcodeArg".

*/

#include <functional> // std::function

namespace cobb {
   class bitvector64 {
      public:
         uint64_t bits = 0;
         uint8_t  size = 0;
         //
         void push(uint64_t bits, uint8_t count) {
            this->bits = (this->bits << count) | bits;
            this->size += count;
         }
   }
}

class OpcodeArgTypeinfo;

class OpcodeArgValue {
   public:
      cobb::bitvector64  data; // raw binary data
      OpcodeArgTypeinfo& type;
      uint8_t            progress = 0; // for compiling, when a single argument internally should be rendered as multiple (and possibly a variable number of) arguments in script code
      QString            english; // for debugging; we retain an English representation of the opcode in memory
}

enum class arg_consume_result {
   failure,
   success,
   still_hungry,
}
class OpcodeArgTypeinfo {
   public:
      using load_functor_t    = std::function<bool(OpcodeArgValue&, void*, uint8_t)>; // loads data from binary stream; returns success/failure; args are the value, starting byte, and offset in bits
      using decode_functor_t  = std::function<bool(OpcodeArgValue&, std::string&)>; // returns success/failure
      using compile_functor_t = std::function<arg_consume_result(OpcodeArgValue&, const std::string&, Compiler&)>;
      //
      QString name;
      QString desc;
      //
      load_functor_t    load       = nullptr;
      decode_functor_t  to_english = nullptr;
      decode_functor_t  decompile  = nullptr;
      compile_functor_t compile    = nullptr;
      //
      // compile_functor_t takes a string representing an argument, and can modify the bits in 
      // an OpcodeArgValue to compile that argument. For types that represent multiple arguments 
      // in script, like the "shape" type, the (progress) on the OpcodeArgValue can be modified 
      // to keep track of what script argument is being decoded, and the functor can return the 
      // arg_consume_result::still_hungry result to indicate that this type should consume more 
      // arguments from the script function call being compiled.
      //
      // It may be easier to implement load_functor_t if we have it take a uint64_t of bits 
      // instead of a buffer and a bit offset. The function which calls the load functor would 
      // basically: peek the next 64 bits from the source bitstream; pass those to the load 
      // functor; and then, if the load functor returns true, check the OpcodeArgValue's size 
      // and skip that many bits in the source bitstream (since the functor already processed 
      // those bits).
      //
      OpcodeArgTypeinfo(
         QString name,
         QString desc,
         load_functor_t    l,
         decode_functor_t  e,
         decode_functor_t  d,
         compile_functor_t c = nullptr // optional for now so that we can add these incrementally once we begin actually implementing a compiler
      )
         : name(name), desc(desc), load(l), to_english(e), decompile(d), compile(c)
      {}
}