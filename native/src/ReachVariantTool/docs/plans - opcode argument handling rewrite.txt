
/*

   Currently, every opcode argument type requires two things: an OpcodeArgValue subclass and an 
   OpcodeArgTypeinfo instance. The value subclass is used to load opcode arguments, retain their 
   values in memory, convert them to string representations, and later reserialize them as 
   binary into a game variant being saved. The typeinfo instance is going to be needed for a 
   compiler.

   So when we load, say, a Vector3 argument, we read the raw bits, store x-, y-, and z-coords, 
   and discard the bits. From this stored data, we can generate string representations, and when 
   it comes time to save the game variant we reconstruct the bits.

   However, we could probably simplify things greatly.

   Consider the following: a single OpcodeArgValue class which holds the raw bits of the opcode 
   argument, the bitcount, and a reference to an OpcodeArgTypeinfo instance; that instance would 
   contain the code to load, stringify, and compile the argument's binary data, provided to its 
   constructor as lambdas. There would be one OpcodeArgTypeinfo instance for every type, but no 
   subclasses of OpcodeArgValue.

   After all, we only need to decode the bits for four reasons:

    - Correctness checks during load.

    - Serializing to plain English.

    - Serializing to script code.

    - Inspecting and tampering with data during debugging.

   None of these reasons require that we keep the argument data in a nice, orderly representation. 
   A Vector3 doesn't need to be held in memory as x-, y-, and z-coords; it can be held as raw 
   bits, with the typeinfo used to stringify it as needed. (On the rare occasions where it's not 
   sufficient to stringify the value, I can just view the bits in my debugger, read through the 
   code to interpret them, and manually reconstruct the value with pen and paper -- slow, but an 
   acceptable price to pay for much smaller and simpler code.)
   
   An additional benefit is the ability to rapidly count the amount of bits that the trigger data 
   will consume. This will in turn make it easy to indicate space usage in the game variant data.
   
   ---
   
   PROBLEMS TO SOLVE:
   
    - Variable declarations -- number and timer variables can be default-initialized to just about 
      any variable/value they can be set to at run-time. We'll need OpcodeArgValues to hold those.
      
       - Speaking of which, we don't actually have any means with which to edit these. We'll need 
         to add them to the (de)compiler, preferably with a new keyword e.g. "declare". This key-
         word would only be needed for setting the initial value of a variable; if you use a var-
         iable without declaring it, then we generate the declaration implicitly.
   
    - Use of cobb::reference_tracked_object to know when script options, player traits, etc., are 
      in use by any opcodes. We'd need to keep an array of refs, I guess, and of course we need to 
      make OpcodeArgValue a reference-tracked object itself. The load functor would fill the array.
      
       - It can be a fixed-length array; we'll never need more than... oh, I don't know, maybe six 
         of these for a single value. We can audit all of the types and figure out the exact max.
      
       - Actually, this requires postprocessing, because Bungie didn't lay out the file format very 
         well. A lot of types can be referred to in script content before they're actually loaded 
         (Forge labels are the simplest example: they appear after all trigger content). So, we'd 
         need a postprocess functor as well.
         
         For simplicity's sake, we should also retool the trigger-loading process so that we can 
         pass the game variant down to the OpcodeArgValue and have it "register" itself to receive 
         a postprocess call. This will all but ensure we avoid another v1.0.5-style mishap where 
         we forget to postprocess some OpcodeArgValue objects because they don't actually appear 
         inside of script data. We'll want to define a class IGameVariantObjectNeedsPostprocessing 
         and use multiple inheritance (which may require that we make reference_tracked_object 
         virtual?).
         
         If we really wanna be paranoid -- and frankly, I do -- we could even store a "is post-
         processed" flag on each OpcodeArgValue and, when saving, warn/assert if the flag isn't 
         set. We'd just need to remember to set it ourselves when compiling.
         
          - I went and defined IGameVariantDataObjectNeedingPostprocess as an abstract base class.
   
   ---
   
   Some notes:
   
    - OpcodeArgValue in this design can store up to 64 bits. 32 bits is not enough; variables with 
      scope, which, and index values can use 16-bit integers as the which and/or index.
   
    - We should implement this before proceeding much further with the decompiler code, since 
      we'll basically get the decompiler for free: we'll have to make it when creating the typeinfo 
      instances. We can do this without breaking the existing code by defining these new classes as 
      OpcodeArgRawValue and OpcodeArgRawTypeinfo; once all types are defined, we can switch the 
      code to use these "raw" classes; and once that code is confirmed to work properly, we can 
      delete the old classes and find-and-replace "OpcodeArgRaw" with "OpcodeArg".
   
    - What approach should we take for enums? Well, I have an idea: first, we define the detailed 
      enum classes described in our plans in main.cpp; we can call them DetailedEnums. Then, we 
      create helper functions with the same signatures as the OpcodeArgTypeinfo functors, BUT that 
      also take a DetailedEnum& as an argument.
      
      For each enum, we create a Typeinfo instance with functors that just call those helper 
      functions, passing the appropriate enum, and return the functions' results. The benefit to 
      this approach is that we can do the same thing for argument types that contain multiple parts 
      including enums; for example, shapes' compile functor can just check whether (progress) is 
      zero and if so, call the enum-compile helper.

*/

#include <functional> // std::function

namespace cobb {
   class bitvector64 {
      public:
         using storage_type = uint64_t;
         //
         storage_type bits = 0;
         uint8_t      size = 0;
         //
         void push(storage_type bits, uint8_t count) {
            this->bits = (this->bits << count) | bits;
            this->size += count;
         }
   }
}

class OpcodeArgTypeinfo;

class OpcodeArgValue {
   public:
      cobb::bitvector64  data; // raw binary data
      OpcodeArgTypeinfo& type;
      uint8_t            progress = 0; // for compiling, when a single argument internally should be rendered as multiple (and possibly a variable number of) arguments in script code
      QString            english; // for debugging; we retain an English representation of the opcode in memory
      //
      using bit_storage_type = decltype(data)::storage_type;
}

enum class arg_consume_result {
   failure,
   success,
   still_hungry,
}
class OpcodeArgTypeinfo {
   public:
      using load_functor_t        = std::function<bool(OpcodeArgValue&, void*, uint8_t)>; // loads data from binary stream; returns success/failure; args are the value, starting byte, and offset in bits
      using decode_functor_t      = std::function<bool(OpcodeArgValue&, std::string&)>; // returns success/failure
      using compile_functor_t     = std::function<arg_consume_result(OpcodeArgValue&, const std::string&, Compiler&)>;
      using postprocess_functor_t = std::function<bool(OpcodeArgValue&, GameVariant&)>;
      //
      struct flags {
         flags() = delete;
         enum type : uint32_t {
            none = 0,
            may_need_postprocessing = 0x00000001,
            is_variable             = 0x00000002,
            is_nestable_variable    = 0x00000004,
            is_static_variable      = 0x00000008, // e.g. player[3], team[3]
         }
      }
      using flags_type = flags::type;
      //
      QString  name;
      QString  desc;
      uint32_t flags = 0;
      //
      load_functor_t        load       = nullptr;
      decode_functor_t      to_english = nullptr;
      decode_functor_t      decompile  = nullptr;
      compile_functor_t     compile    = nullptr;
      postprocess_functor_t postprocess = nullptr;
      //
      // compile_functor_t takes a string representing an argument, and can modify the bits in 
      // an OpcodeArgValue to compile that argument. For types that represent multiple arguments 
      // in script, like the "shape" type, the (progress) on the OpcodeArgValue can be modified 
      // to keep track of what script argument is being decoded, and the functor can return the 
      // arg_consume_result::still_hungry result to indicate that this type should consume more 
      // arguments from the script function call being compiled.
      //
      // It may be easier to implement load_functor_t if we have it take a uint64_t of bits 
      // instead of a buffer and a bit offset. The function which calls the load functor would 
      // basically: peek the next 64 bits from the source bitstream; pass those to the load 
      // functor; and then, if the load functor returns true, check the OpcodeArgValue's size 
      // and skip that many bits in the source bitstream (since the functor already processed 
      // those bits).
      //
      //  = YEAH, DO THIS INSTEAD.
      //
      //  - Peek (cobb::bits_in<OpcodeArgValue::bit_storage_type>) bits so we can easily change 
      //    the max size in bits if necessary (not that it should ever *be* necessary). For 
      //    similar reasons the load functor should take OpcodeArgValue::bit_storage_type as 
      //    the argument type rather than uint64_t (this has the benefit of making the relation-
      //    ships here explicit as well).
      //
      OpcodeArgTypeinfo(
         QString name,
         QString desc,
         uint32_t f,
         load_functor_t        l,
         postprocess_functor_t p,
         decode_functor_t      e,
         decode_functor_t      d,
         compile_functor_t     c = nullptr // optional for now so that we can add these incrementally once we begin actually implementing a compiler
      )
         : name(name), desc(desc), flags(f), load(l), postprocess(p), to_english(e), decompile(d), compile(c)
      {}
}


//
// STUFF FOR ENUMS:
//


struct DetailedEnumValueInfo {
   enum class info_type {
      none,
      bare_string,      // std::string
      localized_string, // QString
      friendly_name, // QString
      description,   // QString
      image,         // bare_string // use for icon enums
      map_tag_type,  // signature   // use for MP object types
      map_tag_path,  // bare_string // use for MP object types
   }
   //
   info_type type = info_type::none;
   union {
      uint32_t    signature = 0;
      QString     string;
      std::string bare_string;
   }
   //
   uint32_t get_signature() {
      if (this->type == info_type::map_tag_type)
         return this->signature;
      return 0;
   }
   //
   // ... etc.
   //
   DetailedEnumValueInfo() {}
   DetailedEnumValueInfo(info_type t, uint32_t s) : type(t), signature(s) {}
   //
   static make_map_tag_type(uint32_t signature) {
      return DetailedEnumValueInfo(info_type::map_tag_type, signature);
   }
   //
   // ... etc.
   //
}
struct DetailedEnumValue {
   std::string name;
   DetailedEnumValueInfo infos[4];
}
struct DetailedEnum {
   std::vector<DetailedEnumValue> values;
}