<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script-type name="player">
   <friendly>Player</friendly>
   <blurb>A player that is or was present in the current match.</blurb>
   <scope
      numbers="8"
      timers="4"
      teams="4"
      players="4"
      objects="4"
   />
   <description>
      <p>
         Player variables refer to players that are participating in the match, or that have 
         participated in the match and since quit. Note that a "player" is distinct from a 
         "player model," or "biped:" if the game has just started and you're still selecting 
         a loadout, then you (the player) still exist even though you're not physically 
         present on the map (you have no biped).
      </p>
      <p>
         There are eight global player variables, numbered from 0 to 7, which can 
         be accessed as <code>global.player[<var>n</var>]</code>.
      </p>
   </description>
   <methods>
      <conditions>
         <method name="killer_type_is" id="3">
            <args>
               <arg name="types">
                  <p>The word <var>none</var>, or one or more of the following flags separated with 
                  the <code>|</code> symbol:</p>
                  <dl>
                     <dt>guardians</dt>
                        <dd>The player was killed by a level boundary or unexplained force.</dd>
                     <dt>suicide</dt>
                        <dd>The player killed themselves.</dd>
                     <dt>kill</dt>
                        <dd>The player was killed by an enemy.</dd>
                     <dt>betrayal</dt>
                        <dd>The player was betrayed by a teammate.</dd>
                     <dt>quit</dt>
                        <dd>The player died because they quit or disconnected from the match.</dd>
                  </dl>
               </arg>
            </args>
            <blurb>Check what killed a player.</blurb>
            <description>
               <p>
                  When called on the exact script tick after a player's death, this function can 
                  be used to check the general circumstances of the player's death. Calling this 
                  function with all permitted values is the primary way to react to a player's 
                  death at the instant that it occurs.
               </p>
            </description>
            <example>
               alias opt_kill_points = script_option[1]
               alias opt_spree_bonus = script_option[0]
               
               for each player do
                  if current_player.killer_type_is(kill) then
                     alias killer = global.player[0]
                     --
                     killer = current_player.get_killer()
                     killer.score += opt_kill_points
                     global.number[0]  = killer.get_spree_count()
                     global.number[0] %= 5
                     if global.number[0] == 0 then
                        --
                        -- This is the player's 5th, 10th, 15th, etc., kill.
                        --
                        killer.score += opt_spree_bonus
                     end
                  end
               end
            </example>
            <category id="player-cause-of-death" />
         </method>
         <method name="is_fireteam_leader" id="9">
            <blurb>This function always returns false.</blurb>
            <description>
               <p>
                  According to kornman00's findings, this function was meant to check if a player 
                  is the "leader" of their fireteam. However, reverse-engineering confirms that 
                  it always returns false.
               </p>
            </description>
            <category id="fireteams" />
         </method>
         <method name="assisted_kill_of" id="10">
            <args>
               <arg name="victim" type="player" />
            </args>
            <blurb>Checks whether one player assisted another in killing a third.</blurb>
            <description>
               <p>
                  This function checks whether the context player assisted in killing the argument 
                  player. Note that players don't count as "assisting" themselves.
               </p>
            </description>
            <example>
               alias opt_kill_points   = script_option[0]
               alias opt_assist_points = script_option[1]
               
               for each player do
                  if current_player.killer_type_is(kill) then
                     alias killer = global.player[0]
                     alias victim = global.player[1]
                     --
                     victim = current_player
                     killer = current_player.get_killer()
                     killer.score += opt_kill_points
                     --
                     for each player do
                        if current_player != victim and current_player.assisted_kill_of(victim) then
                           current_player.score += opt_assist_points
                        end
                     end
                  end
               end
            </example>
            <category id="player-cause-of-death" />
         </method>
         <method name="is_not_respawning" id="12">
            <blurb>Checks whether a player <em>is not</em> respawning.</blurb>
            <note>
               If a match has just started, and a player is waiting to spawn for the first time, 
               then they are not respawning. If you need to know whether the player is or isn't 
               alive, testing whether they have a <a href="script/api/player/properties/biped">biped</a> 
               may be more reliable.
            </note>
            <category id="spawning" />
         </method>
         <method name="is_spartan" id="13">
            <blurb>Checks whether a player's current species is Spartan.</blurb>
            <description>
               <p>
                  This function checks whether a player should spawn as a Spartan based on their 
                  team settings and (when relevant) their preferred species. Its result is not 
                  affected by a script forcing a player into a biped of a different species.
               </p>
            </description>
            <example>
               for each player do
                  if current_player.is_spartan() then 
                     current_player.set_loadout_palette(spartan_tier_1)
                  alt
                     current_player.set_loadout_palette(elite_tier_1)
                  end
               end
            </example>
            <category id="player-species" />
         </method>
         <method name="is_elite" id="14">
            <blurb>Checks whether a player's current species is Elite.</blurb>
            <description>
               <p>
                  This function checks whether a player should spawn as an Elite based on their 
                  team settings and (when relevant) their preferred species. Its result is not 
                  affected by a script forcing a player into a biped of a different species.
               </p>
            </description>
            <example>
               for each player do
                  if current_player.is_elite() then 
                     current_player.set_loadout_palette(elite_tier_1)
                  alt
                     current_player.set_loadout_palette(spartan_tier_1)
                  end
               end
            </example>
            <category id="player-species" />
         </method>
         <method name="is_monitor" id="15">
            <blurb>Checks whether a player's current species is Monitor.</blurb>
            <description>
               <p>
                  This function checks whether a player should spawn as a Monitor based on the 
                  current game settings. However, there are no settings that would actually 
                  cause a player to naturally spawn as a Monitor. This may be a leftover akin 
                  to the <code>game.is_in_forge()</code> condition.
               </p>
            </description>
            <category id="player-species" />
         </method>
      </conditions>
      <actions>
         <method name="apply_traits" id="11">
            <verification>
               <call-on-none safe="true" />
            </verification>
            <args>
               <arg name="traits" type="traits">The player traits to apply.</arg>
            </args>
            <blurb>Apply a set of player traits to a player for the current tick.</blurb>
            <description>
               <p>
                  This function applies a set of player traits to the context player until 
                  the next time the script runs. There is no function to stop applying 
                  traits to a player; rather, you call this function for every tick that 
                  the player should have a given set of traits, and then revoke those 
                  traits by no longer calling this function.
               </p>
            </description>
            <example>
               alias is_zombie     = player.number[0]
               alias zombie_traits = script_traits[0]
               
               for each player do
                  if current_player.is_zombie == 0 then
                     current_player.apply_traits(zombie_traits)
                  end
               end
            </example>
            <category id="traits" />
         </method>
         <method name="try_get_killer" name2="get_killer" id="29" returns="player">
            <blurb>Identify the player who killed this player.</blurb>
            <description>
               <p>
                  When called on a player on the exact frame that that player died, this 
                  function returns the identity of their killer, if any. If the player 
                  died by their own hand, then they themselves are the return value.
               </p>
               <p>
                  When called on any other frame, <em>even while the player is dead</em>, 
                  this function does not return a value:
               </p>
               <ul>
                  <li>
                     If you call <code>get_killer</code>, ReachVariantTool will silently 
                     compile in an assignment to <var>no_player</var> before the call. 
                     (Bungie and 343i do the same thing by hand.) This ensures that if you 
                     call the function at the wrong time, the variable you assign its return 
                     value to will be set to <var>no_player</var>.
                  </li>
                  <li>
                     If you call <code>try_get_killer</code>, then ReachVariantTool does not 
                     compile in this failsafe. If you call <code>try_get_killer</code> at the 
                     wrong time, then the function will not return a value: the variable that 
                     you attempt to assign it to will remain unchanged.
                     <!--
                        This appeared to be the case when reverse-engineering Halo: Reach, 
                        but I wasn't 100% sure; the outcome would've depended on data that 
                        I didn't and don't understand. However, I've confirmed this through 
                        testing, including by setting breakpoints on the relevant code and 
                        stepping through it.
                     -->
                  </li>
               </ul>
            </description>
            <example>
               for each player do
                  if current_player.killer_type_is(guardians | suicide | kill | betrayal | quit) then
                     --
                     -- The player is dead.
                     --
                     global.player[0] = current_player.get_killer()
                     global.player[0].score += 1
                  end
               end
            </example>
            <category id="player-cause-of-death" />
         </method>
         <method name="try_get_death_damage_type" name2="get_death_damage_type" id="30" returns="number">
            <blurb>Identify the type of damage that killed this player.</blurb>
            <description>
               <p>
                  When called on a player on the exact frame that that player died, this 
                  function returns a number representing their cause of death. This number 
                  can represent any cause of death that can be listed in a Post-Game Carnage 
                  Report, including weapons and vehicles. The potential values are listed and 
                  named in the <a href="script/api/ns_enums/damage_reporting_type">damage 
                  reporting type enum</a>.
               </p>
               <p>
                  When called on any other frame, <em>even while the player is dead</em>, 
                  this function does not return a value:
               </p>
               <ul>
                  <li>
                     If you call <code>get_death_damage_type</code>, ReachVariantTool will 
                     silently compile in an assignment to <var>0</var> before the call. 
                     (Bungie and 343i do the same thing by hand.) This ensures that if you 
                     call the function at the wrong time, the variable you assign its return 
                     value to will be set to <var>0</var>.
                  </li>
                  <li>
                     If you call <code>try_get_death_damage_type</code>, then ReachVariantTool 
                     does not compile in this failsafe. If you call <code>try_get_death_damage_type</code> 
                     at the wrong time, then the function will not return a value: the variable 
                     that you attempt to assign it to will remain unchanged.
                     <!--
                        This works the same way as player.get_killer. The code is essentially 
                        identical, looking up the same data structures in the same way and 
                        just accessing different fields.
                     -->
                  </li>
               </ul>
            </description>
            <example>
               --
               -- Award points for killing any other player (including allies) with a DMR.
               --
               for each player do
                  if current_player.killer_type_is(guardians | suicide | kill | betrayal | quit) then
                     --
                     -- The player is dead.
                     --
                     global.number[0] = current_player.get_death_damage_type()
                     if global.number[0] == enums.damage_reporting_type.dmr then
                        global.player[0] = current_player.get_killer()
                        global.player[0].score += 1
                     end
                  end
               end
            </example>
            <category id="player-cause-of-death" />
         </method>
         <method name="try_get_death_damage_mod" name2="get_death_damage_mod" id="31" returns="number">
            <blurb>Identify the modifier for the damage that killed this player.</blurb>
            <description>
               <p>
                  When called on a player on the exact frame that that player died, this 
                  function returns a number representing a modifier for their cause of 
                  death. This number complements the 
                  "<a href="script/api/ns_enums/damage_reporting_type">damage reporting types</a>"
                  that can be listed in a Post-Game Carnage Report. The potential values 
                  are listed and named in the 
                  <a href="script/api/ns_enums/damage_reporting_mod">damage reporting modifier enum</a>.
               </p>
               <p>
                  When called on any other frame, <em>even while the player is dead</em>, 
                  this function does not return a value:
               </p>
               <ul>
                  <li>
                     If you call <code>get_death_damage_mod</code>, ReachVariantTool will 
                     silently compile in an assignment to <var>0</var> before the call. 
                     (Bungie and 343i do the same thing by hand.) This ensures that if you 
                     call the function at the wrong time, the variable you assign its return 
                     value to will be set to <var>0</var>.
                  </li>
                  <li>
                     If you call <code>try_get_death_damage_mod</code>, then ReachVariantTool 
                     does not compile in this failsafe. If you call <code>try_get_death_damage_mod</code> 
                     at the wrong time, then the function will not return a value: the variable 
                     that you attempt to assign it to will remain unchanged.
                     <!--
                        This works the same way as player.get_killer. The code is essentially 
                        identical, looking up the same data structures in the same way and 
                        just accessing different fields.
                     -->
                  </li>
               </ul>
            </description>
            <example>
               --
               -- Award points for killing any other player (including allies) with a splatter.
               --
               for each player do
                  if current_player.killer_type_is(guardians | suicide | kill | betrayal | quit) then
                     --
                     -- The player is dead.
                     --
                     global.number[0] = current_player.get_death_damage_mod()
                     if global.number[0] == enums.damage_reporting_mod.splatter then
                        global.player[0] = current_player.get_killer()
                        global.player[0].score += 1
                     end
                  end
               end
            </example>
            <category id="player-cause-of-death" />
         </method>
         <method name="get_scoreboard_pos" id="32" returns="number">
            <blurb>Get a player's position on the scoreboard.</blurb>
            <description>
               <p>
                  This function returns a player's position on the scoreboard. A value 
                  of 1 represents 1st place, while a value of 0 results if the function 
                  is called on <var>no_player</var>.
               </p>
            </description>
            <example>
               alias leader_traits = script_traits[0]
               
               for each player do
                  global.number[0] = current_player.get_scoreboard_pos()
                  if global.number[0] == 1 then
                     current_player.apply_traits(leader_traits)
                  end
               end
            </example>
            <category id="scoring" />
            <related context="team" type="action" name="get_scoreboard_pos" />
         </method>
         <method name="get_spree_count" id="37" returns="number">
            <blurb>Get the number of players that someone has killed without dying.</blurb>
            <description>
               <p>
                  This function returns the number of players that the context player 
                  has killed without dying.
               </p>
            </description>
            <example>
               alias opt_kill_points = script_option[1]
               alias opt_spree_bonus = script_option[0]
               
               for each player do
                  if current_player.killer_type_is(kill) then
                     alias killer = global.player[0]
                     --
                     killer = current_player.get_killer()
                     killer.score += opt_kill_points
                     global.number[0]  = killer.get_spree_count()
                     global.number[0] %= 5
                     if global.number[0] == 0 then
                        --
                        -- This is the player's 5th, 10th, 15th, etc., kill.
                        --
                        killer.score += opt_spree_bonus
                     end
                  end
               end
            </example>
            <category id="scoring" />
         </method>
         <method name="set_req_purchase_modes" id="39">
            <args>
               <arg name="modes">
                  <p>The word <var>none</var>, or one or more of the following flags 
                  separated with the <code>|</code> symbol:</p>
                  <dl>
                     <dt>alive_weapons</dt>
                        <dd>Unknown.</dd>
                     <dt>alive_equipment</dt>
                        <dd>Unknown.</dd>
                     <dt>alive_vehicles</dt>
                        <dd>Unknown.</dd>
                     <dt>dead_weapons</dt>
                        <dd>Unknown.</dd>
                     <dt>dead_equipment</dt>
                        <dd>Unknown.</dd>
                  </dl>
               </arg>
               <arg name="enable" type="number">A value controlling whether to enable or disable 
                these purchases.</arg>
            </args>
            <blurb>A development leftover related to a scrapped Requisition system.</blurb>
            <description>
               <p>
                  This function apparently modifies what requisition types a player is allowed 
                  to purchase. This appears to be a development leftover for a scrapped design 
                  idea.
               </p>
            </description>
            <example>
               for each player do
                  current_player.set_req_purchase_modes(alive_weapons | alive_equipment | alive_vehicles | dead_weapons | dead_equipment, 1)
               end
            </example>
            <category id="player-money" />
         </method>
         <method name="get_vehicle" name2="try_get_vehicle" id="40" returns="object">
            <verification>
               <call-on-none
                  safe="true"
                  returns-none="true"
               />
            </verification>
            <blurb>Identify the vehicle that a player is in.</blurb>
            <description>
               <p>
                  When called on a player, this function returns the vehicle that the 
                  player is occupying or boarding.
               </p>
               <p>
                  When Bungie and 343i use this function, they often manually clear 
                  the object variable they are assigning to before calling the function. 
                  However, reverse-engineering of the game engine suggests that this is 
                  not actually necessary; the game will always properly return a value 
                  when this function is called.
               </p>
            </description>
            <example>
               --
               -- Award points for killing an enemy using a sniper rifle while riding in a revenant.
               --
               for each player do
                  alias killer  = global.player[0]
                  alias vehicle = global.object[0]
                  if current_player.killer_type_is(kill) then
                     --
                     -- The player is dead.
                     --
                     global.number[0] = current_player.get_death_damage_type()
                     if global.number[0] == enums.damage_reporting_type.sniper_rifle then
                        killer  = current_player.get_killer()
                        vehicle = killer.get_vehicle()
                        if vehicle.is_of_type(revenant) then
                           killer.score += 1
                        end
                     end
                  end
               end
            </example>
            <note>
               As mentioned in the description, this function also works for checking if a player 
               is hijacking or boarding a vehicle. Vehicles can have multiple seats defined for 
               them in the game data, and boarding relies on special "seats" that are flagged as 
               being exclusively for boarding.
            </note>
            <note>
               The alternate name for this function, <code>try_get_vehicle</code>, is deprecated 
               and originates from the oldest versions of ReachVariantTool. In older versions, 
               the two names existed as part of a precaution that reverse-engineering has established 
               was not actually necessary.
            </note>
            <category id="vehicles" />
         </method>
         <method name="force_into_vehicle" id="41">
            <args>
               <arg name="vehicle" type="object">The vehicle to force the player into.</arg>
            </args>
            <blurb>Force a player into a vehicle if any seat is available.</blurb>
            <example>
               --
               -- Force players into Sabres.
               --
               for each player do
                  --
                  -- First, let's make sure the player is actually spawned on the map.
                  --
                  if current_player.biped != no_object then
                     global.object[0] = current_player.get_vehicle()
                     if global.object[0] == no_object then
                        global.object[0] = current_player.biped.place_at_me(sabre, none, none, 0, 0, 0, none)
                        current_player.force_into_vehicle(global.object[0])
                     end
                  end
               end
            </example>
            <note>
               If the vehicle is flipped, then the player will be moved to it, but will not 
               be forced into it. <!-- TODO: RECHECK THIS -->
            </note>
            <category id="vehicles" />
         </method>
         <method name="set_biped" id="42">
            <args>
               <arg name="biped" type="object">The biped to force the player into.</arg>
            </args>
            <blurb>Revoke control of a player's current biped, and grant control of another one.</blurb>
            <description>
               <p>
                  If this function is passed a valid biped, it forces the context player to 
                  abandon control of their current biped and take control of the passed-in 
                  biped. If this function is not passed a valid biped, then it does nothing. 
                  Either way, the player's old biped is not deleted from the map; it simply 
                  becomes an inactive NPC.
               </p>
            </description>
            <example>
               --
               -- Force players into Monitors.
               --
               for each player do
                  if current_player.biped != no_object and not current_player.biped.is_of_type(monitor) then
                     global.object[0] = current_player.biped
                     global.object[1] = current_player.biped.place_at_me(monitor, none, none, 0, 0, 0, none)
                     current_player.set_biped(global.object[1])
                     global.object[0].delete()
                  end
               end
            </example>
            <note>
               <p>
                  Holograms do not <a href="script/api/object/conditions/is_of_type">test</a> 
                  as being Spartans, Elites, or Monitors. However, they are still valid bipeds; 
                  passing a Hologram to <code>set_biped</code> will place the player in control
                  of the biped.
               </p>
               <p>
                  Holograms spawn with a primary weapon only, with a full magazine regardless
                  of how much ammo the caster had left. If a Hologram's player traits don't
                  prevent it from taking damage, then it will be killed when it expires. Any
                  weapons dropped by a Hologram will be deleted instantly; this includes any
                  cases of a Hologram swapping a held weapon for one on the ground. Any items 
                  that a Hologram is carrying at the time it dies or expires will be deleted. 
                  Holograms can use Armor Abilities, but the Hologram ability has no effect 
                  for them because the "hologram" bipeds don't have a "Hologram Unit" set.
               </p>
               <p>
                  If a player is forced to control their own Hologram, this will affect their
                  respawns. If the Hologram dies while under control, they will not be placed
                  back into their original body; instead, they will respawn normally (if the
                  Hologram was killed), or they will instantly appear in a new body such that
                  there is never any frame on which the player has no biped (if the Hologram
                  expires due to its natural timer).
               </p>
            </note>
            <note>
               <p>
                  If necessary, you can spawn a biped inside of a vehicle by spawning the 
                  biped, forcing a player to control it, forcing the player into the vehicle, 
                  and then returning the player to their original biped. However, if the 
                  player is spawned on the map at the time, then there will be a brief cut to 
                  black for that player; they will notice the loss of control. If you need to 
                  spawn NPC bipeds into vehicles, it is best to do this during the initial 
                  loadout camera or while a player is waiting to respawn, if possible.
               </p>
               <p>
                  NPC bipeds that occupy vehicles will behave the same as players who are not 
                  providing any inputs; for example, an NPC-occupied Banshee will fly forward 
                  automatically.
               </p>
            </note>
            <note>
               By default, Monitors spawn with an invisible Focus Rifle, and are capable of 
               picking up weapons, grenades, and Armor Abilities. Monitors can fire any 
               ranged weapon and can use any Armor Ability that does not depend on character 
               model animations (e.g. they can use Active Camo but cannot Sprint); they 
               cannot melee or throw grenades, though they will make melee sounds. Equipped 
               Armor Abilities will be visible on the Monitor's body, displaying their 
               holographic icons as if they were still lying around waiting to be picked up.
            </note>
            <note>
               Once a Megalo-spawned biped has been controlled by a player, it will take on 
               that player's appropriate armor or team color and (if it's a Spartan) its 
               voice will match the player's chosen gender regardless of its own gender 
               presentation. Moreover, in FFA games, the biped will appear allied to the 
               last player who controlled it, even if it appeared as an enemy to them 
               beforehand.
            </note>
            <note>
               <p>
                  You can force a player into a biped while the initial loadout camera is playing, and they 
                  will be able to play early. However, if you do this, the player will hear a constant shrill 
                  beeping, like the ring of an alarm clock. It appears that this beeping plays for every 
                  frame that the player spends in control of a biped, if that player has never controlled a 
                  "natural" biped before; the solution is to ensure that the player has spent at least one 
                  frame in control of a normally-spawned biped before forcing them into a new biped.
               </p>
               <p>
                  I was able to identify the beeping sound; it is defined in the following tags. These tags 
                  seem to have been intended for the Missile Pod, a weapon present only in <i>Halo 3</i>; however, 
                  a search for Missile Pod gameplay videos on YouTube failed to turn up anywhere this exact 
                  sound plays.
               </p>
               <ul>
                  <li>lsnd\sound\weapons\missile_launcher\tracking_locking\locking\loop</li>
                  <li>snd!\sound\weapons\missile_launcher\tracking_locking\locking\loop</li>
               </ul>
               <p>
                  I was unable to locate anything that could use the tag. If the usual community tools for 
                  browsing *.MAP files allow you to search for anything that uses a tag, I haven't managed 
                  to find that feature.
               </p>
            </note>
            <note>
               Suppose a player is given control of a biped and later has that control revoked. If at 
               some point afterward you try to rotate the biped and give the player control over it, all 
               on the same frame, then the rotation will fail: the biped will continue to aim in the last 
               direction the player was aiming when they lost control over it. This can cause issues in 
               cases where you want to switch a player between multiple bipeds, seamlessly; the solution 
               is to rotate the biped on one frame and then wait 'til the next to actually force the 
               player into it.
            </note>
            <note>
               Forcing the player into a dead biped will cause their camera to point toward the ground, 
               and lock their camera more-or-less at ground height. They will be unable to move, pick up 
               weapons, or otherwise interact with the environment. As long as the body remains present, 
               the player will not respawn; if the biped was set by scripts to never be garbage-collected, 
               then the player is effectively trapped.
            </note>
            <category id="bipeds" />
         </method>
         <method name="set_objective_text" name2="set_round_card_title" id="56">
            <args>
               <arg name="text" type="format-string">
                  The description text to display. This is a <a href="script/api/format-string.html#persistent">persistent</a> format string.
               </arg>
            </args>
            <blurb>Change the round card's description text.</blurb>
            <description>
               <p>
                  Typically, at the start of a round in most game modes, the player sees a small informational 
                  popup with a brief blurb describing their objective; this is unofficially called the "round 
                  card." This function sets the body text for the round card.
               </p>
               <p>
                  If the text passed in differs from that used in the previous frame, then this function will 
                  also trigger display of the round card.
               </p>
            </description>
            <example>
               --
               -- Slayer TU round card description code:
               --
               for each player do -- round card
                  if game.score_to_win != 0 and game.teams_enabled == 1 then 
                     current_player.set_round_card_title("Kill players on the enemy team.\r\n%n points to win.", game.score_to_win)
                  end
                  if game.score_to_win != 0 and game.teams_enabled == 0 then 
                     current_player.set_round_card_title("Score points by killing other players.\r\n%n points to win.", game.score_to_win)
                  end
                  if game.score_to_win == 0 and game.teams_enabled == 1 then 
                     current_player.set_round_card_title("Kill players on the enemy team.")
                  end
                  if game.score_to_win == 0 and game.teams_enabled == 0 then 
                     current_player.set_round_card_title("Score points by killing other players.")
                  end
               end
            </example>
            <note>
               The alternate name for this function, <code>set_round_card_title</code>, originates 
               from the oldest versions of ReachVariantTool. It is unintuitive and considered 
               deprecated.
            </note>
            <note>
               Only the first 116 characters of the specified string will be displayed; this limitation 
               applies after all format string parameters are substituted in. It seems that the UI 
               reserves room for 117 characters, including an invisible "end of text" marker.
            </note>
            <note>
               Text does not word wrap automatically; you must insert line breaks manually. The font 
               used to display the text is "TV Nord;" there are font preview websites that you can use 
               to compare line lengths and save yourself a bit of trial and error.
            </note>
            <category id="round-card" />
         </method>
         <method name="set_objective_allegiance_name" name2="set_round_card_text" id="57">
            <args>
               <arg name="text" type="format-string">
                  The icon caption text to display. This is a <a href="script/api/format-string.html#persistent">persistent</a> format string.
               </arg>
            </args>
            <blurb>Change the round card's icon caption.</blurb>
            <description>
               <p>
                  Typically, at the start of a round in most game modes, the player sees a small informational 
                  popup with a brief blurb describing their objective; this is unofficially called the "round 
                  card." The round card can also display an icon and name, usually used if the player is 
                  allied with some in-game faction; this function changes that name.
               </p>
               <p>
                  If the text passed in differs from that used in the previous frame, then this function will 
                  also trigger display of the round card.
               </p>
            </description>
            <example>
               --
               -- Relevant code from Invasion:
               --
               for each player do
                  if current_player.team == team[1] then 
                     current_player.set_round_card_icon(covenant)
                     current_player.set_round_card_text("Elite")
                  end
               end
               for each player do
                  if current_player.team == team[0] then 
                     current_player.set_round_card_icon(noble)
                     current_player.set_round_card_text("Spartan")
                  end
               end
            </example>
            <note>
               The alternate name for this function, <code>set_round_card_text</code>, originates 
               from the oldest versions of ReachVariantTool. It is unintuitive and considered 
               deprecated.
            </note>
            <category id="round-card" />
         </method>
         <method name="set_objective_allegiance_icon" name2="set_round_card_icon" id="58">
            <args>
               <arg name="icon" type="engine-icon" />
            </args>
            <blurb>Change the round card's icon.</blurb>
            <description>
               <p>
                  Typically, at the start of a round in most game modes, the player sees a small informational 
                  popup with a brief blurb describing their objective; this is unofficially called the "round 
                  card." The round card can also display an icon and name, usually used if the player is 
                  allied with some in-game faction; this function changes that icon.
               </p>
               <p>
                  The default icon is the game variant file's icon.
               </p>
            </description>
            <example>
               --
               -- Relevant code from Invasion:
               --
               for each player do
                  if current_player.team == team[1] then 
                     current_player.set_round_card_icon(covenant)
                     current_player.set_round_card_text("Elite")
                  end
               end
               for each player do
                  if current_player.team == team[0] then 
                     current_player.set_round_card_icon(noble)
                     current_player.set_round_card_text("Spartan")
                  end
               end
            </example>
            <category id="round-card" />
         </method>
         <method name="set_primary_respawn_object" id="61">
            <args>
               <arg name="respawn" type="object">The object to use as a respawn point.</arg>
            </args>
            <blurb>This function appears to set a player's default respawn object, when 
            co-op spawning is enabled.</blurb>
            <example>
               --
               -- Excerpt from Invasion:
               --
               for each object with label "inv_res_p1" do
                  --
                  -- Ensure that Phase 1 respawn zones cannot be picked up or destroyed:
                  --
                  current_object.set_spawn_location_permissions(no_one)
                  current_object.set_invincibility(1)
                  current_object.set_pickup_permissions(no_one)
                  --
                  if global.number[2] == 1 then -- current phase is Phase 1?
                     --
                     -- Control which fireteams are allowed to spawn at this respawn zone:
                     --
                     for each object with label "inv_res_p1" do
                        if current_object.spawn_sequence == 0 then 
                           current_object.set_spawn_location_fireteams(0)
                        end
                     end
                     for each object with label "inv_res_p1" do
                        if current_object.spawn_sequence == 1 then 
                           current_object.set_spawn_location_fireteams(1)
                        end
                     end
                     for each object with label "inv_res_p1" do
                        if current_object.spawn_sequence == 2 then 
                           current_object.set_spawn_location_fireteams(2)
                        end
                     end
                     for each object with label "inv_res_p1" do
                        if current_object.spawn_sequence > 2 then 
                           current_object.set_spawn_location_fireteams(all)
                        end
                     end
                     --
                     -- Use the respawn zone's Spawn Sequence to determine which fireteam 
                     -- should use it as their default spawn:
                     --
                     current_object.set_spawn_location_permissions(allies)
                     for each player do
                        if current_object.team == current_player.team then 
                           global.number[8] = 0
                           global.number[8] = current_player.get_fireteam()
                           if current_object.spawn_sequence == global.number[8] then 
                              current_player.set_primary_respawn_object(current_object)
                           end
                        end
                     end
                  end
               end
            </example>
            <category id="spawning" />
         </method>
         <method name="get_fireteam" id="62" returns="number">
            <blurb>Returns the index of the fireteam that a player is on.</blurb>
            <example>
               --
               -- Excerpt from Invasion:
               --
               for each object with label "inv_res_p1" do
                  --
                  -- Ensure that Phase 1 respawn zones cannot be picked up or destroyed:
                  --
                  current_object.set_spawn_location_permissions(no_one)
                  current_object.set_invincibility(1)
                  current_object.set_pickup_permissions(no_one)
                  --
                  if global.number[2] == 1 then -- current phase is Phase 1?
                     --
                     -- Control which fireteams are allowed to spawn at this respawn zone:
                     --
                     for each object with label "inv_res_p1" do
                        if current_object.spawn_sequence == 0 then 
                           current_object.set_spawn_location_fireteams(0)
                        end
                     end
                     for each object with label "inv_res_p1" do
                        if current_object.spawn_sequence == 1 then 
                           current_object.set_spawn_location_fireteams(1)
                        end
                     end
                     for each object with label "inv_res_p1" do
                        if current_object.spawn_sequence == 2 then 
                           current_object.set_spawn_location_fireteams(2)
                        end
                     end
                     for each object with label "inv_res_p1" do
                        if current_object.spawn_sequence > 2 then 
                           current_object.set_spawn_location_fireteams(all)
                        end
                     end
                     --
                     -- Use the respawn zone's Spawn Sequence to determine which fireteam 
                     -- should use it as their default spawn:
                     --
                     current_object.set_spawn_location_permissions(allies)
                     for each player do
                        if current_object.team == current_player.team then 
                           global.number[8] = 0
                           global.number[8] = current_player.get_fireteam()
                           if current_object.spawn_sequence == global.number[8] then 
                              current_player.set_primary_respawn_object(current_object)
                           end
                        end
                     end
                  end
               end
            </example>
            <category id="fireteams" />
         </method>
         <method name="set_fireteam" id="63">
            <args>
               <arg name="index" type="number" />
            </args>
            <blurb>Sets a player's current fireteam index.</blurb>
            <category id="fireteams" />
         </method>
         <method name="set_requisition_palette" id="69">
            <args>
               <arg name="palette">The index of a palette to use. Values between 0 and 15, 
               inclusive, are possible, but the actual valid range is not known.</arg>
            </args>
            <blurb>A development leftover related to a scrapped Requisition system.</blurb>
            <description>
               <p>
                  This function sets which requisition palette the player can use. This 
                  appears to be a development leftover for a scrapped design idea.
               </p>
            </description>
            <category id="player-money" />
         </method>
         <method name="set_loadout_palette" id="77">
            <args>
               <arg name="palette">
                  <p>Any of the following values:</p>
                  <ul>
                     <li>none</li>
                     <li>spartan_tier_1</li>
                     <li>spartan_tier_2</li>
                     <li>spartan_tier_3</li>
                     <li>elite_tier_1</li>
                     <li>elite_tier_2</li>
                     <li>elite_tier_3</li>
                  </ul>
               </arg>
            </args>
            <blurb>Sets which loadout palette a player can select loadouts from.</blurb>
            <example>
               for each player do
                  if current_player.is_elite() then 
                     current_player.set_loadout_palette(elite_tier_1)
                  alt
                     current_player.set_loadout_palette(spartan_tier_1)
                  end
               end
            </example>
         </method>
         <method name="get_weapon" name2="try_get_weapon" id="83" returns="object">
            <args>
               <arg name="which">
                  <p>Any one of the following values</p>
                  <dl>
                     <dt>primary</dt>
                        <dd>The weapon that the player is currently using</dd>
                     <dt>secondary</dt>
                        <dd>The weapon that the player has holstered.</dd>
                  </dl>
               </arg>
            </args>
            <blurb>Identify the player's current weapon.</blurb>
            <description>
               <p>
                  This function can be used to access a player's readied or holstered 
                  weapon.
               </p>
               <p>
                  When Bungie and 343i use this function, they often manually clear 
                  the object variable they are assigning to before calling the function. 
                  However, reverse-engineering of the game engine suggests that this is 
                  not actually necessary; the game will always properly return a value 
                  when this function is called.
               </p>
            </description>
            <example>
               --
               -- Delete the player's weapon if it is not a Gravity Hammer:
               --
               for each player do
                  global.object[0] = current_player.get_weapon(secondary)
                  if not global.object[0].is_of_type(gravity_hammer) then
                     global.object[0].delete()
                  end
                  global.object[0] = current_player.get_weapon(primary)
                  if not global.object[0].is_of_type(gravity_hammer) then
                     global.object[0].delete()
                  end
               end
            </example>
            <note>
               The alternate name for this function, <code>try_get_weapon</code>, is deprecated 
               and originates from the oldest versions of ReachVariantTool. In older versions, 
               the two names existed as part of a precaution that reverse-engineering has established 
               was not actually necessary.
            </note>
            <category id="biped-equipment" />
            <category id="weapons" />
         </method>
         <method name="get_armor_ability" name2="try_get_armor_ability" id="84" returns="object">
            <blurb>Identify the player's current Armor Ability.</blurb>
            <description>
               <p>
                  This function can be used to access a player's readied or holstered 
                  weapon.
               </p>
               <p>
                  When Bungie and 343i use this function, they often manually clear 
                  the object variable they are assigning to before calling the function. 
                  However, reverse-engineering of the game engine suggests that this is 
                  not actually necessary; the game will always properly return a value 
                  when this function is called.
               </p>
            </description>
            <example>
               --
               -- Don't allow players to use Armor Lock:
               --
               for each player do
                  global.object[0] = current_player.get_armor_ability()
                  if global.object[0].is_of_type(armor_lock) and global.object[0].is_in_use() then
                     global.object[0].delete()
                     game.show_message_to(current_player, none, "nope")
                  end
               end
            </example>
            <note>
               The alternate name for this function, <code>try_get_armor_ability</code>, is deprecated 
               and originates from the oldest versions of ReachVariantTool. In older versions, 
               the two names existed as part of a precaution that reverse-engineering has established 
               was not actually necessary.
            </note>
            <category id="armor-abilities" />
            <category id="biped-equipment" />
         </method>
         <method name="get_crosshair_target" id="86" returns="object">
            <blurb>Identify the object that the player is aiming at, if that object 
            is changing the player's reticle color.</blurb>
            <description>
               <p>
                  This function returns the object that the current player is aiming at, if 
                  that object is giving the player a red or green reticle. It only appears 
                  to work when called on host.
               </p>
            </description>
         </method>
         <method name="add_weapon" id="89">
            <args>
               <arg name="weapon"  type="object" />
            </args>
            <blurb>Give a weapon to a player.</blurb>
            <example>
               global.player[0].add_weapon(global.object[0])
            </example>
            <note>
               Remember that this function works differently from <code>object.add_weapon</code>: 
               the object function takes an object type and spawns a new weapon; while the player 
               function takes an existing weapon object.
            </note>
            <category id="biped-equipment" />
         </method>
         <method name="set_co_op_spawning" id="90">
            <args>
               <arg name="enable" type="bool" />
            </args>
            <blurb>Control whether a player uses co-op spawning.</blurb>
            <description>
               <p>
                  This function controls whether players use co-op spawning, an alternate 
                  spawning system that allows players to spawn at their teammates or at 
                  any object on the map that has been appropriately configured. This is 
                  the spawning system used in Invasion and Buddy Slayer (formerly called 
                  "Bro Slayer").
               </p>
            </description>
            <example>
               for each player do
                  current_player.set_co_op_spawning(true) -- enable it
               end
            </example>
            <category id="spawning" />
         </method>
         <method name="record_griefer_penalty" id="97">
            <args>
               <arg name="penalty amount" type="number">
                  The penalty amount to add to the player. The precise scale is not known, but 
                  the values that you specify are divided by 100 when the game engine runs this 
                  function.
               </arg>
            </args>
            <blurb>The specific function of this action is not known. Presumably it has something 
            to do with keeping track of bad behavior in-game.</blurb>
         </method>
         <method name="get_button_press_duration" name2="get_button_time" id="101" returns="number">
            <args>
               <arg name="button">
                  <p>
                     The name of a gameplay function to which a button can be mapped. In the following 
                     list, title-cased names (e.g. "Gameplay Function Name") refer to options in the 
                     MCC's gamepad control scheme editor.
                  </p>
                  <dl>
                     <dt>jump</dt>
                        <dd>The button that's currently mapped to Jump.</dd>
                     <dt>switch_grenade</dt>
                        <dd>The button that's mapped to cycling through your grenades. This matches MCC's 
                        "Switch Grenades" function, but <em>not</em> "Select Next Grenade" or "Select 
                        Previous Grenade."</dd>
                     <dt>context_primary</dt>
                        <dd>The button that's currently mapped to Action.</dd>
                     <dt>melee_attack</dt>
                        <dd>The button that's currently mapped to meleeing.</dd>
                     <dt>equipment</dt>
                        <dd>The button that's currently mapped to Use Armor Ability.</dd>
                     <dt>throw_grenade</dt>
                        <dd>The button that's currently mapped to throwing a grenade.</dd>
                     <dt>fire_primary</dt>
                        <dd>The button that's currently mapped to Fire.</dd>
                     <dt>crouch</dt>
                        <dd>The button that's currently mapped to crouching.</dd>
                     <dt>scope_zoom</dt>
                        <dd>The button that's currently mapped to toggling your scope/zoom.</dd>
                     <dt>night_vision</dt>
                        <dd>The button that's currently mapped to Toggle Night Vision.</dd>
                     <dt>fire_secondary</dt>
                        <dd>The button that's currently mapped to Vehicle Function 1.</dd>
                     <dt>fire_tertiary</dt>
                        <dd>Unknown. This appears to always react to the B button; it doesn't correspond 
                        to any of the controls that MCC allows players to rebind in custom control schemes, 
                        and it doesn't differ between any of the built-in control schemes.</dd>
                     <dt>vehicle_trick</dt>
                        <dd>Either of the buttons mapped to Vehicle Function 2 and Vehicle Function 3.</dd>
                  </dl>
               </arg>
            </args>
            <blurb>MCC-exclusive: Detect whether a player is holding a given button down. Intended for 
            debugging purposes only.</blurb>
            <description>
               <p>
                  This function was added to the <i>Halo: The Master Chief Collection</i> build of <i>Halo: Reach</i> 
                  in mid-July 2023, being backported from <i>Halo 4</i>'s Megalo engine. Gametypes that 
                  use this function will likely fail to load on Xbox 360 builds of <i>Halo: Reach</i> 
                  (even when played via Xbox One backward compatibility).
               </p>
               <p>
                  This function checks whether a specified gameplay-related button is being held down on 
                  the gamepad; if so, it returns the number of script ticks for which the button has been 
                  held down. This function does not react to the keyboard, only works on host, and per 
                  statements by 343i developers is intended for debugging purposes only.
               </p>
               <p>
                  When multiple functions are mapped to the same button, they do not block each other; 
                  this function will return the same time in script ticks for both of them. Although 
                  buttons are identified by their mapped function (i.e. "the Jump button" instead of "A"), 
                  this function will return the correct duration even if the player is unable to trigger 
                  the mapped function. Players that are on the respawn screen, or out of grenades, for 
                  example, can still be detected as pressing the "throw grenades" button.
               </p>
               <p>
                  Per a 343i employee, this function is not "deterministic." It doesn't synch across the 
                  network or in Theater. If a gametype ever actually reacts to this function in any way 
                  that affects game or map state, then a Theater film of that play session will immediately 
                  desynch at that point in the match, rendering playback past that point impossible (Theater 
                  will show an error message and then forcibly return you to the lobby). To paraphrase the 
                  employee: "You should only use it for debugging, as a last resort."
               </p>
            </description>
            <example>
               for each player do
                  global.number[0] = current_player.get_button_press_duration(jump)
               end
            </example>
            <note>
               This function will never return a value higher than 255 (equivalent to 4.25 seconds).
            </note>
         </method>
         <method name="set_vehicle_spawning_enabled" id="103">
            <args>
               <arg name="enable" type="bool">
                  <p>
                     Control whether this player spawns in a vehicle (true) or not (false).
                  </p>
               </arg>
            </args>
            <blurb>MCC-exclusive: Although intended to let you control whether players spawn in vehicles 
            or not, this function doesn't appear to actually do anything.</blurb>
            <description>
               <p>
                  This function was added to the <i>Halo: The Master Chief Collection</i> build of <i>Halo: Reach</i> 
                  in mid-July 2023, being backported from <i>Halo 4</i>'s Megalo engine. Gametypes that 
                  use this function will likely fail to load on Xbox 360 builds of <i>Halo: Reach</i> 
                  (even when played via Xbox One backward compatibility).
               </p>
               <p>
                  This function was intended to let you control whether players spawn in a vehicle or not; 
                  it would allow you to set a spawn vehicle via <a href="script/api/player/actions/set_respawn_vehicle">set_respawn_vehicle</a>, 
                  without having to set the spawn vehicle type to none in order to disable vehicle spawning.
               </p>
               <p>
                  In tests, this function doesn't actually do anything. Disassembly of haloreach.dll 
                  shows that it is, as of this writing, a no-op: it contains no code and has no effect.
               </p>
            </description>
            <example>
               for each player do
                  current_player.set_respawn_vehicle(warthog)
                  current_player.set_vehicle_spawning_enabled(false)
               end
            </example>
            <related context="team" type="method" name="set_vehicle_spawning_enabled" />
            <related context="player" type="method" name="set_respawn_vehicle" />
            <related context="team" type="method" name="set_respawn_vehicle" />
         </method>
         <method name="set_respawn_vehicle" id="104">
            <args>
               <arg name="vehicle type" type="object_type">
                  <p>
                     The vehicle type that this player should respawn in.
                  </p>
               </arg>
            </args>
            <blurb>MCC-exclusive: Automatically spawn players inside of vehicles, without having to manually 
            create vehicles and force players into them.</blurb>
            <description>
               <p>
                  This function was added to the <i>Halo: The Master Chief Collection</i> build of <i>Halo: Reach</i> 
                  in mid-July 2023, being backported from <i>Halo 4</i>'s Megalo engine. Gametypes that 
                  use this function will likely fail to load on Xbox 360 builds of <i>Halo: Reach</i> 
                  (even when played via Xbox One backward compatibility).
               </p>
               <p>
                  This function allows you to set the respawn vehicle type for a player: when the player
                  respawns, the game engine will automatically create a vehicle of this type and then
                  force the player into one of its seats, preferring the driver's seat if accessible
                  (and if compatible with the player's biped). In essence, this automates the task of
                  using <a href="script/api/object/actions/place_at_me">player.biped.place_at_me</a>
                  and <a href="script/api/player/actions/force_into_vehicle">player.force_into_vehicle</a> 
                  in tandem.
               </p>
            </description>
            <example>
               for each player do
                  current_player.set_respawn_vehicle(warthog)
               end
            </example>
            <note>
               If you specify an object type that is not defined on the current map, then the game will stop 
               spawning the target player in a vehicle. However, if you specify an object type that isn't a 
               vehicle and is defined on the current map, then this function will have no effect, and the 
               player's respawn vehicle will remain unchanged.
            </note>
            <related context="team" type="method" name="set_respawn_vehicle" />
            <related context="player" type="method" name="set_vehicle_spawning_enabled" />
            <related context="team" type="method" name="set_vehicle_spawning_enabled" />
         </method>
      </actions>
   </methods>
   <properties>
      <property name="biped" type="object" read-only="true">
         <blurb>The player's current biped.</blurb>
         <description>
            <p>
               This property allows you to access the biped a player is currently 
               in control of. If the player is not in control of a biped, e.g. 
               because they haven't spawned yet or they've been killed, then this 
               property's value will be <code>no_object</code>.
            </p>
         </description>
         <note>
            This is the only property that can be accessed on nested variables, e.g. 
            <var>current_team.player[0].biped</var>.
         </note>
         <category id="bipeds" />
      </property>
      <property name="rating" type="number" read-only="true">
         <blurb>The player's Arena rating.</blurb>
      </property>
      <property name="score" type="number" setter-is-accessor="true">
         <blurb>The player's current score.</blurb>
         <description>
            <p>
               The player's current score. The value is capped at 30,000; attempting to 
               increase it past 30,000 will simply set it to 30,000.
            </p>
            <p>
               Player scores cannot hold values outside the range [-32,768, 32,767].
            </p>
         </description>
         <example>
            --
            -- Award a player one point for every frame they spend alive:
            --
            for each player do
               if current_player.biped != no_object then
                  --
                  -- If the player has a biped on the map, then they must be alive.
                  --
                  current_player.score += 1
               end
            end
         </example>
         <category id="scoring" />
         <related context="team" type="property" name="score" />
      </property>
      <property name="script_stat" type="number" indexed="true">
         <blurb>The value of a scripted Post-Game Carnage Report stat for this player.</blurb>
         <description>
            <p>
               This member allows you to access the values of script-defined Post-Game Carnage 
               Report stats on a per-player basis. Stats can be read or modified. Their values 
               persist between rounds, making them a useful way to persist state between rounds.
            </p>
            <p>
               Scripted stats cannot hold values outside the range [-32,768, 32,767].
            </p>
         </description>
         <example>
            for each player do
               current_player.script_stat[3] += 5
            end
         </example>
         <category id="scoring" />
         <related context="team" type="property" name="script_stat" />
      </property>
      <property name="team" type="team">
         <blurb>The player's owner team.</blurb>
         <description>
            <p>
               The team that this player belongs to.
            </p>
            <p>
               This property can be assigned to, but only in Free-For-All games; this is how 
               gametypes like Infection are able to split players into separate factions. 
               Assigning to this property during Team games has no effect; if teams are 
               enabled within the gametype, then you cannot forcibly change a player's team 
               using scripts.
            </p>
         </description>
         <example>
            for each player do
               if current_player.team == team[0] then
                  --
                  -- Player is on Team 1.
                  --
               end
            end
         </example>
         <related context="object" type="property" name="team" />
      </property>
      <property name="money" type="number" setter-is-accessor="true">
         <blurb>The player's money, to spend on requisitions as part of an unimplemented gameplay system.</blurb>
         <description>
            <p>
               This value is limited to the range [-32,768, 32,767] and represents how much 
               money the player has on hand to spend on requisitions.
            </p>
         </description>
         <category id="player-money" />
      </property>
   </properties>
   <accessors>
      <accessor name="frag_grenades" type="number" setter="opcode" id="74">
         <blurb>The player's current frag grenade count.</blurb>
         <description>
            <p>
               The player's current frag grenade count. The count is capped at 4; attempting 
               to increase it past this number will simply set it to 4 instead.
            </p>
         </description>
         <example>
            for each player do
               current_player.frag_grenades += 1
            end
         </example>
         <category id="biped-equipment" />
      </accessor>
      <accessor name="plasma_grenades" type="number" setter="opcode" id="74">
         <blurb>The player's current plasma grenade count.</blurb>
         <description>
            <p>
               The player's current plasma grenade count. The count is capped at 4; attempting
               to increase it past this number will simply set it to 4 instead.
            </p>
         </description>
         <example>
            for each player do
               current_player.plasma_grenades += 1
            end
         </example>
         <category id="biped-equipment" />
      </accessor>
   </accessors>
</script-type>