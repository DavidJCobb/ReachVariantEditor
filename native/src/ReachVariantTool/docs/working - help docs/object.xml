<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script-type name="object">
   <friendly>Object</friendly>
   <blurb>An object in the game world.</blurb>
   <methods>
      <conditions>
         <method name="shape_contains" id="2">
            <args>
               <arg name="other" type="object" />
            </args>
            <blurb>Check whether this object's shape boundary contains another object.</blurb>
            <description>
               <p>
                  This function checks whether the context object contains <var>other</var>'s 
                  pivot point. An object's pivot point is usually its centerpoint or center of 
                  mass, but there are exceptions; for example, a Sabre's pivot point is located 
                  roughly at the bottom of its landing gear, while a Dice's pivot point is 
                  located very slightly off-center on the "six" face.
               </p>
               <p>
                  If <var>other</var> is attached to some parent object, then this function 
                  tests the parent object's pivot point rather than <var>other</var>'s pivot 
                  point.
               </p>
            </description>
            <example>
               --
               -- Drain the shields of all players in the hill.
               --
               for each player do
                  if current_hill.shape_contains(current_player.biped) then
                     current_player.biped.shields = 0
                  end
               end
            </example>
         </method>
         <method name="is_of_type" id="6">
            <args>
               <arg name="type" type="object-type" />
            </args>
            <blurb>Check whether this object is of a given type.</blurb>
            <description>
               <p>
                  This function checks whether the context object is of a given type.
               </p>
            </description>
            <example>
               --
               -- Do not allow Elites to pick up Assault Rifles.
               --
               for each player do
                  if current_player.biped.is_of_type(elite) then
                     for each object do
                        if current_object.is_of_type(assault_rifle) then
                           current_object.set_pickup_permissions(mod_player, current_player, 0)
                        end
                     end
                  end
               end
            </example>
            <note>
               Holograms do not test as being of type <var>spartan</var> or <var>elite</var>.
            </note>
         </method>
         <method name="is_out_of_bounds" id="8">
            <blurb>Check whether this object is out of bounds.</blurb>
            <description>
               <p>
                  This condition function tests as true if the context object is outside of 
                  the level's defined playable space, or if the context object is inside of 
                  a Forge-placed Kill Boundary or Soft Kill Boundary.
               </p>
            </description>
            <example>
               --
               -- Delete objects that fall out of bounds.
               --
               for each object do
                  if current_object.is_out_of_bounds() then
                     current_object.delete()
                  end
               end
            </example>
         </method>
         <method name="has_forge_label" id="11">
            <blurb>Check whether this object has a given Forge label.</blurb>
            <args>
               <arg name="label" type="forge-label" />
            </args>
            <example>
               for each player do
                  global.object[0] = current_player.get_weapon(primary)
                  if global.object[0].has_forge_label("bad_weapon") then
                     current_player.biped.kill(false)
                  end
               end
            </example>
         </method>
         <method name="is_in_use" id="13">
            <blurb>Check whether this object is an Armor Ability currently being used by a player.</blurb>
            <example>
               for each player do
                  global.object[0] = current_player.get_armor_ability()
                  if global.object[0].is_of_type(armor_lock) and global.object[0].is_in_use() then
                     global.object[0].delete()
                     game.show_message_to(current_player, none, "don't do that")
                  end
               end
            </example>
         </method>
      </conditions>
      <actions>
         <method name="place_at_me" id="2" returns="object">
            <args>
               <arg name="type"  type="object-type" />
               <arg name="label" type="forge-label" />
               <arg name="flags">
                  <p>The word <var>none</var>, or one or more of the following flags separated with 
                  the <code>|</code> symbol:</p>
                  <dl>
                     <dt>never_garbage_collect</dt>
                        <dd>Prevents the created object from being garbage-collected.</dd>
                     <dt>suppress_effect</dt>
                        <dd>Unknown.</dd>
                     <dt>absolute_orientation</dt>
                        <dd>Unknown.</dd>
                  </dl>
               </arg>
               <arg type="vector-3">
                  A position offset from the context object.
               </arg>
               <arg type="variant-string-id">
                  A variation to apply to the created object, if the object type supports it.
               </arg>
            </args>
            <blurb>Spawn a new object at this object.</blurb>
            <example>
               --
               -- Spawn a Spartan with Kat's armor:
               --
               global.object[0] = global.object[1].place_at_me(spartan, none, never_garbage_collect, 0, 0, 0, kat)
            </example>
            <note>
               The new object will be created as close to the context object as possible. It will 
               not be created exactly at the context object, even if one or both of the objects 
               are non-solid. To create one object exactly at another object, 
               <a href="script/api/object/actions/attach_to">attach</a> 
               the created object to the basis object and then 
               <a href="script/api/object/actions/detach">detach</a> 
               it.
            </note>
         </method>
         <method name="delete" id="3">
            <blurb>Delete this object from the game world.</blurb>
            <example>
               for each object with label "team_only" do
                  if game.teams_enabled == 0 then
                     current_object.delete()
                  end
               end
               for each object with label "ffa_only" do
                  if game.teams_enabled != 0 then
                     current_object.delete()
                  end
               end
            </example>
            <note>
               Deleting a player's current biped will cause them to instantaneously respawn, 
               without deducting from their pool of lives in limited-life game variants. 
               Continuously deleting their biped over a span of time will cause the screen 
               to hard-cut to black for them, with no HUD widgets visible and no game sounds 
               audible besides some announcer voiceovers.
            </note>
         </method>
         <method name="set_waypoint_visibility" id="4">
            <args>
               <arg name="who" type="player-set" />
            </args>
            <blurb>Adjust who can see this object's waypoint.</blurb>
            <example>
               for each object with label "race_flag" do
                  current_object.set_waypoint_visibility(everyone)
               end
            </example>
            <related type="action" name="set_waypoint_icon" />
            <related type="action" name="set_waypoint_priority" />
            <related type="action" name="set_waypoint_timer" />
            <related type="action" name="set_waypoint_range" />
         </method>
         <method name="set_waypoint_icon" id="5">
            <args>
               <arg name="icon" type="waypoint-icon" />
            </args>
            <blurb>Change the icon that this waypoint displays.</blurb>
            <example>
               for each object with label "koth_hill" do
                  current_object.set_waypoint_icon(defend)
               end
            </example>
            <!-- relationships only need to be specified on one end -->
         </method>
         <method name="set_waypoint_priority" id="6">
            <args>
               <arg name="priority">
                  <p>Any of the following values:</p>
                  <dl>
                     <dt>low</dt>
                        <dd>The waypoint will be translucent &mdash; almost invisible, in fact.</dd>
                     <dt>normal</dt>
                        <dd>The waypoint will be normally visible.</dd>
                     <dt>high</dt>
                        <dd>The waypoint is visible even when the object is off-screen?</dd>
                     <dt>blink</dt>
                        <dd>The waypoint will blink rapidly. This is usually used for urgent waypoints, like a territory under attack in Invasion.</dd>
                  </dl>
               </arg>
            </args>
            <blurb>Change the waypoint's visual priority.</blurb>
            <example>
               for each object with label 2 do -- let's pretend this is all landmines
                  current_object.set_waypoint_priority(low)
               end
            </example>
            <!-- relationships only need to be specified on one end -->
         </method>
         <method name="set_waypoint_timer" id="7">
            <args>
               <arg name="timer">
                  The word <var>none</var>, or an integer constant indicating the index of an 
                  object.timer variable, or a relative alias of an object-timer variable 
                  prefixed with <code>object.</code> i.e. <code>object.alias_name</code>.
               </arg>
            </args>
            <blurb>Change the timer that a waypoint displays.</blurb>
            <example>
               for each object with label "koth_hill" do
                  current_object.set_waypoint_timer(3)
               end
               
               alias capture_timer = object.timer[0]
               for each object with label "territory" do
                  current_object.set_waypoint_timer(object.capture_timer)
               end
               
               for each object with label "ignore_me" do
                  current_object.set_waypoint_timer(none)
               end
            </example>
            <!-- relationships only need to be specified on one end -->
         </method>
         <method name="set_waypoint_range" id="8">
            <args>
               <arg name="min" type="number">
                  A number between -1 and 100, inclusive. A value of 10 represents one Forge 
                  unit.
               </arg>
               <arg name="max" type="number">
                  A number between -1 and 100, inclusive. A value of 10 represents one Forge 
                  unit.
               </arg>
            </args>
            <blurb>Change the distances at which waypoints are visible.</blurb>
            <example>
               for each object with label "koth_hill" do
                  current_object.set_waypoint_range(0, 50)
               end
            </example>
            <!-- relationships only need to be specified on one end -->
         </method>
         <method name="set_shape" id="10">
            <args>
               <arg name="type">
                  <p>Any of the following values:</p>
                  <dl>
                     <dt>none</dt>
                        <dd>The object will have no shape.</dd>
                     <dt>sphere</dt>
                        <dd>The object will have a shape with one dimension: a radius.</dd>
                     <dt>cylinder</dt>
                        <dd>The object will have a shape with three dimensions: a radius, top, and bottom.</dd>
                     <dt>box</dt>
                        <dd>The object will have a shape with four dimensions: a width, length, top, and bottom.</dd>
                  </dl>
               </arg>
               <arg name="..." type="number">
                  Zero or more dimensions for the shape, as appropriate for the given type. 
                  A value of 10 represents one Forge unit.
               </arg>
            </args>
            <blurb>Change an object's shape boundary.</blurb>
            <description>
               <p>
                  This function allows you to change an object's shape boundary. Shape 
                  boundaries can be set in Forge and changed at run-time by a gametype 
                  script. Scripts can make boundaries visible to some or all players, 
                  and test whether objects or players are inside of the boundaries.
               </p>
            </description>
            <example>
               for each object with label "use_none" do
                  current_object.set_shape(none)
               end
               for each object with label "use_sphere" do
                  current_object.set_shape(sphere, 10)
               end
               for each object with label "use_cylinder" do
                  current_object.set_shape(cylinder, 10, 10, 10)
               end
               for each object with label "use_box" do
                  current_object.set_shape(box, 10, 10, 10, 10)
               end
            </example>
            <related type="condition" name="shape_contains" />
            <related type="action" name="set_shape_visibility" />
            <related type="action" name="apply_shape_color_from_player_member" />
         </method>
         <method name="set_pickup_permissions" id="12">
            <args>
               <arg name="who" type="player-set" />
            </args>
            <blurb>Adjust which players can pick up a weapon.</blurb>
            <description>
               <p>
                  This function allows you to control which players are allowed to pick up a 
                  given weapon. It only works on weapons (including flags, bombs, and skulls) 
                  and does nothing when used on other objects, such as vehicles and grenades.
               </p>
               <p>
                  The typical use case for this is to prevent teams from interacting with 
                  objective weapons, e.g. preventing a team from moving their own flag in 
                  Capture the Flag, or preventing a team from moving the enemy bomb in 
                  Assault.
               </p>
            </description>
            <example>
               --
               -- Do not allow Elites to pick up Assault Rifles.
               --
               for each player do
                  if current_player.biped.is_of_type(elite) then
                     for each object do
                        if current_object.is_of_type(assault_rifle) then
                           current_object.set_pickup_permissions(mod_player, current_player, 0)
                        end
                     end
                  end
               end
            </example>
         </method>
         <method name="set_spawn_location_permissions" id="13">
            <args>
               <arg name="who" type="player-set" />
            </args>
            <blurb>Adjust which players can spawn at a location.</blurb>
            <description>
               <p>
                  This function allows you to control which players are allowed to spawn at 
                  the context object. This applies to players that have been 
                  <a href="script/api/player/actions/set_co_op_spawning">set to use co-op 
                  spawning</a>.
               </p>
            </description>
            <example>
               alias current_checkpoint = global.object[0]
               alias next_checkpoint    = global.object[1]
               --
               -- Let's pretend that this is Race, and a player just reached next_checkpoint. 
               -- We want the player to be able to respawn at the last checkpoint they've 
               -- reached.
               --
               current_checkpoint.set_spawn_location_permissions(mod_player, current_player, 0)
               next_checkpoint.set_spawn_location_permissions(mod_player, current_player, 1)
            </example>
            <related context="player" type="action" name="set_co_op_spawning" />
            <related type="action" name="set_spawn_location_fireteam" />
         </method>
         <method name="set_spawn_location_fireteam" id="14">
            <args>
               <arg name="fireteam" type="number">
                  The fireteam index to limit this object to, or -1 to indicate that any 
                  fireteam should be able to spawn at this object.
               </arg>
            </args>
            <blurb>Adjust which fireteam can spawn at a location.</blurb>
            <description>
               <p>
                  This function allows you to limit a spawn location to a specific fireteam. 
                  This applies to players that have been 
                  <a href="script/api/player/actions/set_co_op_spawning">set to use co-op 
                  spawning</a>.
               </p>
            </description>
            <example>
               for each object with label "fireteam_1_spawn" do
                  current_object.set_spawn_location_fireteam(1)
                  current_object.set_spawn_location_permissions(allies)
               end
            </example>
         </method>
         <method name="set_progress_bar" id="15">
            <args>
               <arg name="who" type="player-set" />
               <arg name="timer">
                  The word <var>none</var>, or an integer constant indicating the index of an 
                  object.timer variable, or a relative alias of an object-timer variable 
                  prefixed with <code>object.</code> i.e. <code>object.alias_name</code>.
               </arg>
            </args>
            <blurb>Set whether an object displays a progress bar, and who should be able to see it.</blurb>
            <example>
               for each object with label "koth_hill" do
                  current_object.set_progress_bar(everyone, 3)
               end
               
               alias capture_timer = object.timer[0]
               for each object with label "territory" do
                  for each player do
                     current_object.set_progress_bar(mod_player, current_player, 1, object.capture_timer)
                  end
               end
               
               for each object with label "ignore_me" do
                  current_object.set_progress_bar(everyone, none)
               end
            </example>
         </method>
         <method name="get_carrier" id="19" returns="player">
            <blurb>Identify the player carrying a weapon.</blurb>
            <example>
               for each object with label "awful_gun" do
                  global.player[0] = current_object.get_carrier()
                  if global.player[0] != no_player then
                     global.player[0].kill(false)
                  end
               end
            </example>
         </method>
         <method name="set_shape_visibility" id="22">
            <args>
               <arg name="who" type="player-set" />
            </args>
            <blurb>Adjust which players can see an object's shape boundary.</blurb>
            <example>
               for each object with label "territory" do
                  current_object.set_shape_visibility(everyone)
               end
            </example>
            <note>
               You cannot make objects with spherical shapes visible. Spherical shapes are 
               only available via scripting, not in Forge, and the game apparently has no 
               code to display them.
            </note>
         </method>
         <method name="kill" id="23">
            <args>
               <arg name="silent" type="bool">
                  Controls whether the object's death counts toward any statistics.
               </arg>
            </args>
            <blurb>Kill an object.</blurb>
            <example>
               for each object with label "avoid_me" do
                  for each player do
                     if current_object.shape_contains(current_player.biped) then
                        current_player.biped.kill(false)
                     end
                  end
               end
            </example>
         </method>
         <method name="set_invincibility" id="24">
            <args>
               <arg name="state" type="number">
                  If this value is non-zero, the object is made invincible.
               </arg>
            </args>
            <blurb>Make an object invincible.</blurb>
            <description>
               <p>
                  This function makes an object invulnerable. Invulnerable objects cannot 
                  be killed or destroyed by weapons, explosions, physics, Forge-placed level 
                  boundaries, a map's built-in level boundaries, or (in the case of bipeds) 
                  the destruction of the vehicle they are piloting, or any other form of 
                  damage.
               </p>
            </description>
            <example>
               for each player do
                  current_player.biped.set_invincibility(1)
               end
            </example>
         </method>
         <method name="get_orientation" id="29" returns="number">
            <blurb>Returns a number representing the object's overall rotation.</blurb>
            <description>
               <p>
                  This function returns a number between 1 and 6 representing an object's 
                  overall rotation. The values seem to indicate which side of an object 
                  is facing up, i.e. if you were to imagine a cube enclosing the object, 
                  the values would each correspond to one side of the cube.
               </p>
               <p>
                  Analysis of the code for Rocket Hog Race indicates that a value of 1 
                  indicates that the object is upright (Rocket Hog Race uses this to 
                  count the number of times a player's vehicle has rotated); however, 
                  tests on various objects pre-rotated in Forge always returned 1.
               </p>
            </description>
            <example>
               global.number[0] = current_object.get_orientation()
               if global.number[0] != 1 then
                  --
                  -- object isn't upright
                  --
               end
            </example>
         </method>
         <method name="get_speed" id="30" returns="number">
            <blurb>Returns the object's speed in feet per second.</blurb>
            <description>
               <p>
                  This function returns an object's speed, apparently measured in feet 
                  per second. Race multiplies the value by 109 and then divides by 100 
                  to convert it to kilometers per hour.
               </p>
            </description>
            <example>
               global.number[0] = current_object.get_speed()
            </example>
         </method>
      </actions>
   </methods>
</script-type>