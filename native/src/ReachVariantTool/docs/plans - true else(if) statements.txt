
Consider the following code:

   if x == 0 then
      x = 1
   else
      crash_the_game()
   end

That code cannot be directly compiled in Megalo. The language has no else(if) construct. 
Simply copying and negating conditions isn't sufficient here; that would give us this 
code:

   if x == 0 then
      x = 1
   end
   if x != 0 then
      crash_the_game()
   end

In order to have a true "else" statement, we need to burn a variable on checking state:

   exec = 1
   if x == 0 then
      exec = 0
      x = 1
   end
   if exec == 1 then
      crash_the_game()
   end

This doesn't allow for else-if statements, however:

   if     x == 0 then
      a()
   elseif y == 0 then -- x != 0 and y == 0
      b()
   elseif z == 0 then -- x != 0 and y != 0 and z == 0
      c()
   end

This, too, can be implemented properly using a single boolean variable, if we realize 
that a set of elseifs is logically equivalent to a set of nested elses:

   if x == 0 then
      a()
   else
      if y == 0 then
         b()
      else
         if z == 0 then
            c()
         end
      end
   end

Using a boolean variable instead of else statements, we get:

   exec = 1
   if x == 0 then
      exec = 0
      a()
   end
   if exec == 1 then
      if y == 0 then
         exec = 0
         b()
      end
      if exec == 1 then
         if z == 0 then
            c()
         end
      end
   end

However, a single boolean variable is insufficient for handling nested structures:

   if x == 0 then
      a()
   elseif y == 0 then
      b()
      if u == 0 then
         d()
      elseif v == 0 then
         e()
      elseif w == 0 then
         f()
      end
      g()
   elseif z == 0 then
      c()
   end

The above snippet needs two booleans:

   outer = 1
   if x == 0 then
      outer = 0
      a()
   end
   if outer == 1 then
      if y == 0 then
         outer = 0
         b()
         inner = 1
         if u == 0 then
            inner = 0
            d()
         end
         if inner == 1 then
            if v == 0 then
               inner = 0
               e()
            end
            if inner == 1 then
               if w == 0 then
                  inner = 0
                  f()
               end
            end
         end
         g()
      end
      if outer == 1 then
         if z == 0 then
            c()
         end
      end
   end

At this point, it seems like we're coming close to having code that could be automatically 
generated by a script compiler. It's not a problem that this code is very, very ugly, 
because it's not code that a script author should be seeing.

Ignoring user-defined functions for a moment, two variables are sufficient for handling 
15 levels of nesting. The first variable would act as a bitmask holding fifteen booleans, 
while the second variable would be used to test any given bit. (Megalo uses 16-bit ints, 
but bitwise operations on the sign bit seem to behave unpredictably.)

Let's invert our booleans: instead of tracking whether the next branch at a given depth 
should run, let's track whether any branch at a given depth has already run. For ease of 
understanding, let's demonstrate just a single level of depth; recall the code snippet 
from earlier:

   if     x == 0 then
      a()
   elseif y == 0 then -- x != 0 and y == 0
      b()
   elseif z == 0 then -- x != 0 and y != 0 and z == 0
      c()
   end

With a 15-bit mask, we get:

   else_mask = 0
   else_test = 0
   if x == 0 then
      else_mask |= 0b01
      a()
   end
   else_test  = else_mask
   else_test &= 0b01
   if else_test == 0 then
      if y == 0 then
         else_mask |= 0b01
         b()
      end
      else_test  = else_mask
      else_test &= 0b01
      if else_test == 0 then
         if z == 0 then
            c()
         end
      end
   end

However, this approach isn't suitable for user-defined functions: a user-defined function 
has no information about its caller, and so cannot know which bits in the else-mask are 
already in use by else(if) branches in the caller. Let's try burning an additional integer 
to track the current bit to test. Megalo didn't have bitshifts in Halo: Reach, but luckily 
we only need to shift by one bit at a time, and we can do that by multiplying and dividing 
by two.

   declare else_mask -- else state
   declare else_flag -- which bit we're on, i.e. (1 << i)
   declare else_test -- used to test a bit
   
   --
   -- NOTE: User-defined functions are used here to keep the else-related operations 
   -- legible. In actual compiled code, operations consisting of only a single instruction 
   -- (or two) would be inlined rather than compiled as function calls.
   --

   function _else_dec()
      else_mask ~= else_flag -- clear the bit
      else_flag /= 2
   end
   function _else_inc()
      else_flag *= 2
      if else_flag == 0 then
         else_flag = 1
      end
   end
   function _else_set()
      else_mask |= else_flag
   end
   function _else_test()
      else_test  = else_mask
      else_test &= else_flag
   end

   --
   -- if x == 0 then
   --    a()
   -- elseif y == 0 then
   --    b()
   -- elseif z == 0 then
   --    c()
   -- end
   --

   _else_inc()
   if x == 0 then
      _else_set()
      a()
   end
   _else_test()
   if else_test == 0 then
      if y == 0 then
         _else_set()
         b()
      end
      _else_test()
      if else_test == 0 then
         if z == 0 then
            c()
         end
      end
   end
   _else_dec()

Recall our nested elseif example from above; with this setup, it would look like this:

   _else_inc()
   if x == 0 then
      _else_set()
      a()
   end
   _else_test()
   if else_test == 0 then
      if y == 0 then
         _else_set()
         b()
         --
         _else_inc()
         if u == 0 then
            _else_set()
            d()
         end
         _else_test()
         if else_test == 0 then
            if v == 0 then
               _else_set()
               e()
            end
            _else_test()
            if else_test == 0 then
               if w == 0 then
                  _else_set()
                  f()
               end
            end
         end
         _else_dec()
         --
         g()
      end
      _else_test()
      if else_test == 0 then
         if z == 0 then
            c()
         end
      end
   end
   _else_dec()

There is, however, a way to avoid burning a third variable. With the approach above, the 
least-significant bits in our else-mask are for the outermost elseifs, and the most sig-
nificant bits are for the innermost elseifs. We can flip the bit order and always use the 
least significant bit as the current bit, shifting the entire else-mask and avoiding the 
need to track an index:

   function _else_dec()
      else_mask /= 2 -- equivalent to m >> 1
   end
   function _else_inc()
      else_mask *= 2 -- equivalent to m << 1
   end
   function _else_set()
      else_mask |= 1
   end
   function _else_test()
      else_test  = else_mask
      else_test &= 1
   end

This would allow for the use of true else(if) statements in user-defined functions provided 
the else(if) statements don't nest deeper than fifteen levels. (Do remember that recursion 
would contribute to that limit if the recursive call is inside of an else(if) statement.)

The total overhead of this approach is:

 - Two global number variables consumed (though else_test is just a temporary; the script 
   author could use it as a temporary in their own code as well, so long as they remember 
   that its value won't persist past the next else(if) branch).

 - One action before and after every else(if) tree (_else_inc and _else_dec).

    - In Megalo, conditions are written into triggers and last to the end of those triggers; 
      an if-block only requires its own trigger if it is not the last child item in its 
      parent trigger. Because an action must appear after every else(if) statement, the last 
      branch of every such statement will require its own trigger; we consume one more 
      trigger than would be necessary without using this approach.

 - One trigger per else(if) branch, including the initial if-branch but excluding the final 
   branch. Recall that we are converting the else(if) tree into a set of nested elses.

 - An extra action (_else_set) on the inside of every branch in an else(if) tree, except for 
   the last branch.

 - An extra condition per else(if) branch (but not for the initial if-branch), along with 
   either two actions, or one action (a function call) along with one trigger (_else_test) 
   for the whole script.

This means that the minimum extra content needed for a "true" else(if) tree with (n) branches 
(including the initial if-branch) is:

           2 variables
   2 + 2 * n actions
           n conditions
           n triggers (with one additional trigger shared by all else(if) trees)

The total overhead is:

   2 variables
    - One to track else-specific state, and another to check it

   n * 2 triggers
    - One trigger per branch
    - One trigger per elseif branch converted to nested else and if

   2 + 2 * (n - 1) + 2 * n actions
    - Two actions per else(if) tree
    - One action for all branches except the initial branch
    - One action for all branches except the final branch
    - One action for every nested trigger that needs to be called

   n + (n - 1) conditions
    - One condition per branch (assuming each branch has only one condition)
    - One condition per elseif branch converted to nested else and if

   15-tree nesting limit
    - Our bitmask has 15 usable bits
    - No generic way to handle overflow (e.g. throwing an exception, etc.)
    - The script author would actually have to be aware of this limitation
    - How would we even begin to explain it to them
    - What a nightmare
    - That limitation would be so ugly it's almost not worth it to implement this at all

   Correct "else" behavior in all cases that fit under the limits
    - Neat!

By contrast, if we approximate elseif trees using separate if-blocks which may potentially 
interfere with each other...

   if x == 0 then
      a()
   end
   if x != 0 and y == 0 then
      b()
   end
   if x != 0 and y != 0 and z == 0 then
      c()
   end

...then the overhead is:

   0 variables
    - No else-specific state is tracked

   n triggers
    - One trigger per branch

   n actions (potentially n - 1)
    - One action for every nested trigger that needs to be called
    - If the tree is the last item in its parent trigger, then its last branch can be inlined

   n + (n - 1) + (n - 2) + ... conditions
    - Each branch must include negated copies of the conditions for all prior branches

   No nesting limit
    - No else-specific state is tracked
   
   Incorrect "else" behavior in certain cases
    - Could just use a different name for it